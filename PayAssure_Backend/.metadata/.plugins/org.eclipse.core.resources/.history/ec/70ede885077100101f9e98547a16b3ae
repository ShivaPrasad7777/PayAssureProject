// BillingService.java
package com.example.service;

import com.example.dto.CustomerSummary;
import com.example.dto.PolicySummary;
import com.example.model.Customer;
import com.example.model.Invoice;
import com.example.model.Notification;
import com.example.model.Payment;
import com.example.model.Policy;
import com.example.model.TaxRate;
import com.example.repository.CustomerRepository;
import com.example.repository.InvoiceRepository;
import com.example.repository.NotificationRepository;
import com.example.repository.PaymentRepository;
import com.example.repository.PolicyRepository;
import com.example.repository.TaxRateRepository;
import com.razorpay.Order;
import com.razorpay.RazorpayClient;
import com.razorpay.RazorpayException;
import com.razorpay.PaymentLink;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.Calendar;
import java.util.stream.Collectors;

@Service
public class BillingService {

    private static final Logger log = LoggerFactory.getLogger(BillingService.class);

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private PolicyRepository policyRepository;

    @Autowired
    private PaymentRepository paymentRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private TaxRateRepository taxRateRepository;

    private final RazorpayClient razorpayClient;

    public BillingService(
            @Value("${razorpay.key-id}") String keyId,
            @Value("${razorpay.key-secret}") String keySecret) throws RazorpayException {
        this.razorpayClient = new RazorpayClient(keyId, keySecret);
    }

    public Invoice createInvoice(String customerId, List<String> policyIds, String insurerId, Date dueDate, int months) throws RazorpayException {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));

        Date currentDate = new Date();
        List<String> validPolicyIds = new ArrayList<>();
        List<Invoice.TaxDetails> taxDetailsList = new ArrayList<>();
        double totalAmount = 0.0;

        // Loop to validate policies and calculate dynamic amounts/taxes
        for (String policyId : policyIds) {
            Policy policy = policyRepository.findById(policyId)
                    .orElseThrow(() -> new RuntimeException("Policy not found"));

            // Constraint check (skip if not expired - no status check)
            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
                    .filter(entry -> entry.getPolicyId().equals(policyId))
                    .findFirst();

            if (historyEntry.isPresent()) {
                Customer.PaymentHistoryEntry entry = historyEntry.get();
                if (!currentDate.after(entry.getValidUpto())) {
                    log.warn("Skipping policy {}: Valid until {}", policyId, entry.getValidUpto());
                    continue;
                }
            } else {
                log.info("No payment history for policy {}; including in invoice", policyId);
            }

            // Fetch tax rate dynamically from collection
            String taxRateId = policy.getPolicyType();
            TaxRate taxRate = taxRateRepository.findById(taxRateId)
                    .orElseThrow(() -> new RuntimeException("TaxRate not found for ID: " + taxRateId));

            // Calculate per-policy
            double baseAmount = policy.getMonthlyPremium() * months;
            double gstAmount = baseAmount * taxRate.getGstRate();
            double policyTotal = baseAmount + gstAmount;
            totalAmount += policyTotal;

            // Add per-policy tax details
            Invoice.TaxDetails taxDetails = new Invoice.TaxDetails();
            taxDetails.setPolicyId(policyId);  // Associate with policy
            taxDetails.setGstRate(taxRate.getGstRate());
            taxDetails.setTaxAmount(gstAmount);
            taxDetails.setTotalAmount(policyTotal);
            taxDetailsList.add(taxDetails);

            validPolicyIds.add(policyId);
        }

        if (validPolicyIds.isEmpty()) {
            throw new RuntimeException("No valid policies to generate invoice");
        }

        // Correct way to generate order ID: Create order first
        JSONObject orderRequest = new JSONObject();
        orderRequest.put("amount", (int) (totalAmount * 100)); // In paise
        orderRequest.put("currency", "INR");
        orderRequest.put("receipt", "receipt_multi_" + customerId);
        Order razorpayOrder = razorpayClient.orders.create(orderRequest);
        String generatedOrderId = razorpayOrder.get("id");
        log.info("Generated Razorpay Order ID: {}", generatedOrderId);

        // Generate payment link (cannot directly tie 'order_id' due to API limitation, but add to notes for reference)
        JSONObject linkRequest = new JSONObject();
        linkRequest.put("amount", (int) (totalAmount * 100));
        linkRequest.put("currency", "INR");
        linkRequest.put("accept_partial", false);
        linkRequest.put("reference_id", customerId + "_" + System.currentTimeMillis());
        linkRequest.put("description", "Payment for multiple policies");
        linkRequest.put("customer", new JSONObject()
                .put("name", customer.getName())
                .put("email", customer.getEmail())
                .put("contact", customer.getPhone()));
        linkRequest.put("notify", new JSONObject().put("sms", true).put("email", true));
        linkRequest.put("reminder_enable", true);
        linkRequest.put("notes", new JSONObject()
                .put("customerId", customerId)
                .put("order_id", generatedOrderId)); // Add order_id to notes for webhook reference
        PaymentLink paymentLink = razorpayClient.paymentLink.create(linkRequest);
        String linkUrl = paymentLink.get("short_url");
        log.info("Generated Payment Link: {}", linkUrl);

        // Create single invoice
        Invoice invoice = new Invoice();
        invoice.setCustomerId(customerId);
        invoice.setInsurerId(insurerId);
        invoice.setPolicyIds(validPolicyIds);  // List of included policies
        invoice.setAmount(totalAmount);
        invoice.setStatus("unpaid");
        invoice.setValidUpto(dueDate != null ? dueDate : calculateDueDate(currentDate, months));
        invoice.setRazorpayOrderId(generatedOrderId);
        invoice.setCreatedAt(new Date());
        invoice.setPaymentLink(linkUrl);
        invoice.setMonths(months);
        invoice.setTaxDetailsList(taxDetailsList);  // Per-policy tax details

        // Save invoice
        Invoice savedInvoice = invoiceRepository.save(invoice);
        log.info("Saved invoice ID: {} with razorpayOrderId: {}", savedInvoice.getId(), generatedOrderId);

        // Update customer's paymentHistory for each policy
        for (String policyId : validPolicyIds) {
            updatePaymentHistory(customer, policyId, savedInvoice.getValidUpto());
        }
        customerRepository.save(customer);

        return savedInvoice;
    }

    // Helper method for due date
    private Date calculateDueDate(Date currentDate, int months) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(currentDate);
        cal.add(Calendar.MONTH, months);
        return cal.getTime();
    }

    // Helper method to update paymentHistory for a policy
    private void updatePaymentHistory(Customer customer, String policyId, Date newValidUpto) {
        Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
                .filter(entry -> entry.getPolicyId().equals(policyId))
                .findFirst();

        if (historyEntry.isPresent()) {
            Customer.PaymentHistoryEntry entry = historyEntry.get();
            entry.setStatus("pending invoice");
            entry.setValidUpto(newValidUpto);
        } else {
            Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
            newEntry.setPolicyId(policyId);
            newEntry.setStatus("pending invoice");
            newEntry.setValidUpto(newValidUpto);
            customer.getPaymentHistory().add(newEntry);
        }
    }


    public String initiatePayment(String invoiceId, String customerId) throws RazorpayException {
        Invoice invoice = invoiceRepository.findById(invoiceId)
                .orElseThrow(() -> new RuntimeException("Invoice not found"));

        if (!invoice.getCustomerId().equals(customerId)) {
            throw new RuntimeException("Unauthorized");
        }

        if (!"unpaid".equals(invoice.getStatus())) {
            throw new RuntimeException("Invoice already paid");
        }

        return invoice.getRazorpayOrderId();
    }
    
    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
        try {
            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));

            log.info("Invoice loaded with policyIds: {}", invoice.getPolicyIds());

            invoice.setStatus("paid");
            invoiceRepository.save(invoice);

            Payment payment = new Payment();
            payment.setInvoiceId(invoice.getId());
            payment.setCustomerId(invoice.getCustomerId());
            payment.setInsurerId(invoice.getInsurerId());
            payment.setAmount(invoice.getAmount());
            payment.setStatus(status);
            payment.setRazorpayPaymentId(razorpayPaymentId);

            List<String> policyIds = invoice.getPolicyIds();
            if (policyIds != null && !policyIds.isEmpty()) {
                payment.setPolicyIds(policyIds);
                List<String> policyNames = policyRepository.findAllById(policyIds)
                    .stream()
                    .map(Policy::getName)
                    .collect(Collectors.toList());
                log.info("Policy Names: {}", policyNames);
                payment.setPolicyNames(policyNames);
            } else {
                log.warn("No policy IDs found for invoice: {}", invoice.getId());
            }

            paymentRepository.save(payment);

            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
        } catch (Exception e) {
            log.error("Payment verification failed", e);
            throw new RuntimeException("Payment verification failed: " + e.getMessage());
        }
    }


//    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
//        try {
//            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
//            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//            invoice.setStatus("paid");
//            invoiceRepository.save(invoice);
//
//            Payment payment = new Payment();
//            payment.setInvoiceId(invoice.getId());
//            payment.setCustomerId(invoice.getCustomerId());
//            payment.setInsurerId(invoice.getInsurerId());
//            payment.setAmount(invoice.getAmount());
//            payment.setStatus(status);
//            payment.setRazorpayPaymentId(razorpayPaymentId);
//       
//            
//            payment.setPolicyIds(invoice.getPolicyIds());
//            List<String> policyNames = policyRepository.findAllById(invoice.getPolicyIds())
//                                         .stream()
//                                         .map(Policy::getName)
//                                         .collect(Collectors.toList());
//            payment.setPolicyNames(policyNames);
//
//            paymentRepository.save(payment);
//
//            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
//        } catch (Exception e) {
//            log.error("Payment verification failed", e);
//            throw new RuntimeException("Payment verification failed: " + e.getMessage());
//        }
//    }

    private void sendNotification(String invoiceId, String customerId, String insurerId) throws RazorpayException {
        Notification notification = new Notification();
        notification.setCustomerId(customerId);
        notification.setInvoiceId(invoiceId);
        notification.setInsurerId(insurerId);
        notification.setType("email");
        notification.setMessage("Payment successful for invoice " + invoiceId);
        notificationRepository.save(notification);
        // Add external sending logic (e.g., Twilio or SendGrid)
    }

    // NEW METHOD: Get unpaid customers
    public List<CustomerSummary> getUnpaidCustomers() {
        Date currentDate = new Date();
        List<Customer> allCustomers = customerRepository.findAll();
        return allCustomers.stream()
                .filter(customer -> customer.getPaymentHistory().stream()
                        .anyMatch(entry -> currentDate.after(entry.getValidUpto())))
                .map(customer -> new CustomerSummary(customer.getId(), customer.getName()))
                .collect(Collectors.toList());
    }

    // NEW METHOD: Get unpaid policies for a customer
    public List<PolicySummary> getUnpaidPoliciesForCustomer(String customerId) {
        Date currentDate = new Date();
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));

        List<String> unpaidPolicyIds = customer.getPaymentHistory().stream()
                .filter(entry -> currentDate.after(entry.getValidUpto()))
                .map(Customer.PaymentHistoryEntry::getPolicyId)
                .collect(Collectors.toList());

        List<Policy> unpaidPolicies = policyRepository.findAllById(unpaidPolicyIds);

        return unpaidPolicies.stream()
                .map(policy -> new PolicySummary(policy.getId(), policy.getName()))  // FIXED: Use policy.getName() for display
                .collect(Collectors.toList());
    }
    
    public void processCashPayment(String invoiceId) {
        log.info("Processing cash payment for invoiceId: {}", invoiceId);

        // Find the invoice
        Optional<Invoice> optionalInvoice = invoiceRepository.findById(invoiceId);
        if (optionalInvoice.isEmpty()) {
            log.error("Invoice not found for ID: {}", invoiceId);
            throw new RuntimeException("Invoice not found");
        }
        Invoice invoice = optionalInvoice.get();

        // Check if already paid
        if (!"unpaid".equals(invoice.getStatus())) {
            log.warn("Invoice {} is not unpaid, current status: {}", invoiceId, invoice.getStatus());
            throw new RuntimeException("Invoice is not eligible for payment");
        }

        // Update invoice status to "paidByCash"
        invoice.setStatus("paidByCash");
        invoiceRepository.save(invoice);
        log.info("Updated invoice {} status to paidByCash", invoiceId);

        // Create and save payment record
        Payment payment = new Payment();
        payment.setInvoiceId(invoice.getId());
        payment.setCustomerId(invoice.getCustomerId());
        payment.setInsurerId(invoice.getInsurerId());
        payment.setAmount(invoice.getAmount());
        payment.setStatus("paidByCash");  // Updated to match invoice status
        payment.setRazorpayPaymentId(null); // No Razorpay for cash
        payment.setRazorpaySubscriptionId(null);
        payment.setMethod("cash");
        payment.setIsAutoPay(false);
        payment.setPaidAt(new Date());

        // Assuming you need to add taxDetails to Payment (based on sample data)
        // If your Payment entity doesn't have it, add a field: private TaxDetails taxDetails; (or List<TaxDetails> if multi-policy)
        // For simplicity, copying from invoice (adjust if needed)
        if (!invoice.getTaxDetailsList().isEmpty()) {
            // Example: Take the first one or aggregate; here assuming single for demo
            Invoice.TaxDetails invoiceTax = invoice.getTaxDetailsList().get(0);
            Payment.TaxDetails taxDetails = new Payment.TaxDetails();
            taxDetails.setTaxType("GST"); // Assuming based on sample
            taxDetails.setTaxRate(invoiceTax.getGstRate());
            taxDetails.setTaxAmount(invoiceTax.getTaxAmount());
            taxDetails.setTotalAmount(invoiceTax.getTotalAmount());
            payment.setTaxDetails(taxDetails); // Add this field to your Payment entity if not present
        }
        payment.setPolicyIds(invoice.getPolicyIds());
        List<String> policyNames = policyRepository.findAllById(invoice.getPolicyIds())
                                     .stream()
                                     .map(Policy::getName)
                                     .collect(Collectors.toList());
        payment.setPolicyNames(policyNames);

        paymentRepository.save(payment);
        log.info("Created payment record for invoice {}", invoiceId);

        // Update customer payment history
        Optional<Customer> optionalCustomer = customerRepository.findById(invoice.getCustomerId());
        if (optionalCustomer.isEmpty()) {
            log.error("Customer not found for ID: {}", invoice.getCustomerId());
            throw new RuntimeException("Customer not found");
        }
        Customer customer = optionalCustomer.get();

        Date paymentDate = new Date();
        for (String policyId : invoice.getPolicyIds()) {
            // Find or create payment history entry for the policy
            Optional<Customer.PaymentHistoryEntry> optionalEntry = customer.getPaymentHistory().stream()
                    .filter(entry -> entry.getPolicyId().equals(policyId))
                    .findFirst();

            Customer.PaymentHistoryEntry entry = optionalEntry.orElseGet(() -> {
                Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
                newEntry.setPolicyId(policyId);
                customer.getPaymentHistory().add(newEntry);
                log.info("Created new history entry for policy {}", policyId);
                return newEntry;
            });

            // Update entry
            entry.setStatus("paidByCash");  // Updated to match invoice status
            entry.setLastPaidDate(paymentDate);
            Calendar cal = Calendar.getInstance();
            cal.setTime(paymentDate);
            cal.add(Calendar.MONTH, invoice.getMonths());
            entry.setValidUpto(cal.getTime());
            log.info("Updated policy {} validUpto to {}", policyId, entry.getValidUpto());
        }

        customerRepository.save(customer);
        log.info("Updated customer payment history for ID: {}", customer.getId());
    }
    
 // Update BillingService: Add or modify methods to fetch all payments (without insurerId filter)
    public List<Payment> getAllPaymentHistory() {
        log.info("Fetching all payment history system-wide");
        Sort sort = Sort.by(Sort.Direction.DESC, "paidAt"); // Newest to oldest
        return paymentRepository.findAll(sort);
    }
    
 // NEW: Get customer by ID
    public Optional<Customer> getCustomerById(String customerId) {
        return customerRepository.findById(customerId);
    }

    // NEW: Get invoice by ID
    public Optional<Invoice> getInvoiceById(String invoiceId) {
        return invoiceRepository.findById(invoiceId);
    }

    // NEW: Get policies by IDs (returns full Policy objects; you can map to summaries if needed)
    public List<Policy> getPoliciesByIds(List<String> policyIds) {
        return policyRepository.findAllById(policyIds);
    }
    public List<Invoice> getAllInvoiceHistory() {
        log.info("Fetching all invoice history system-wide");
        Sort sort = Sort.by(Sort.Direction.DESC, "createdAt"); // Newest to oldest
        return invoiceRepository.findAll(sort);
    }
    
 // Add to BillingService.java

 // NEW: Search customers by name (case-insensitive partial match)
 public List<CustomerSummary> searchCustomersByName(String name) {
     log.info("Searching customers with name containing: {}", name);
     List<Customer> matchingCustomers = customerRepository.findByNameContainingIgnoreCase(name);
     return matchingCustomers.stream()
             .map(customer -> new CustomerSummary(customer.getId(), customer.getName()))
             .collect(Collectors.toList());
 }

//NEW: Get unpaid and failed invoices for a customer
public List<Invoice> getUnpaidFailedInvoicesForCustomer(String customerId) {
  log.info("Fetching unpaid/failed invoices for customer: {}", customerId);
  return invoiceRepository.findByCustomerIdAndStatusIn(customerId, List.of("unpaid", "failed"));  // Assumes status can be "unpaid" or "failed"; adjust as needed
}

//NEW: Process cash payment for multiple invoices
public void processCashPaymentMultiple(List<String> invoiceIds) {
  log.info("Processing cash payment for multiple invoices: {}", invoiceIds);
  for (String invoiceId : invoiceIds) {
      processCashPayment(invoiceId);  // Reuse your existing single-invoice method for each
  }
}
}




//remove checkstatus
//package com.example.service;
//
//import com.example.dto.CustomerSummary;
//import com.example.dto.PolicySummary;
//import com.example.model.Customer;
//import com.example.model.Invoice;
//import com.example.model.Notification;
//import com.example.model.Payment;
//import com.example.model.Policy;
//import com.example.model.TaxRate;
//import com.example.repository.CustomerRepository;
//import com.example.repository.InvoiceRepository;
//import com.example.repository.NotificationRepository;
//import com.example.repository.PaymentRepository;
//import com.example.repository.PolicyRepository;
//import com.example.repository.TaxRateRepository;
//import com.razorpay.Order;
//import com.razorpay.RazorpayClient;
//import com.razorpay.RazorpayException;
//import com.razorpay.PaymentLink;
//import org.json.JSONObject;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.data.domain.Sort;
//import org.springframework.stereotype.Service;
//
//import java.util.ArrayList;
//import java.util.Date;
//import java.util.List;
//import java.util.Optional;
//import java.util.Calendar;
//import java.util.stream.Collectors;
//
//@Service
//public class BillingService {
//
//    private static final Logger log = LoggerFactory.getLogger(BillingService.class);
//
//    @Autowired
//    private InvoiceRepository invoiceRepository;
//
//    @Autowired
//    private PolicyRepository policyRepository;
//
//    @Autowired
//    private PaymentRepository paymentRepository;
//
//    @Autowired
//    private NotificationRepository notificationRepository;
//
//    @Autowired
//    private CustomerRepository customerRepository;
//
//    @Autowired
//    private TaxRateRepository taxRateRepository;
//
//    private final RazorpayClient razorpayClient;
//
//    public BillingService(
//            @Value("${razorpay.key-id}") String keyId,
//            @Value("${razorpay.key-secret}") String keySecret) throws RazorpayException {
//        this.razorpayClient = new RazorpayClient(keyId, keySecret);
//    }
//
//    public Invoice createInvoice(String customerId, List<String> policyIds, String insurerId, Date dueDate, int months) throws RazorpayException {
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        Date currentDate = new Date();
//        List<String> validPolicyIds = new ArrayList<>();
//        List<Invoice.TaxDetails> taxDetailsList = new ArrayList<>();
//        double totalAmount = 0.0;
//
//        // Loop to validate policies and calculate dynamic amounts/taxes
//        for (String policyId : policyIds) {
//            Policy policy = policyRepository.findById(policyId)
//                    .orElseThrow(() -> new RuntimeException("Policy not found"));
//
//            // Constraint check (skip if not unpaid and expired)
//            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            if (historyEntry.isPresent()) {
//                Customer.PaymentHistoryEntry entry = historyEntry.get();
//                if (!currentDate.after(entry.getValidUpto()) || !"unpaid".equals(entry.getStatus())) {
//                    log.warn("Skipping policy {}: Valid until {} or status not unpaid", policyId, entry.getValidUpto());
//                    continue;
//                }
//            } else {
//                log.info("No payment history for policy {}; including in invoice", policyId);
//            }
//
//            // Fetch tax rate dynamically from collection
//            String taxRateId = policy.getPolicyType();
//            TaxRate taxRate = taxRateRepository.findById(taxRateId)
//                    .orElseThrow(() -> new RuntimeException("TaxRate not found for ID: " + taxRateId));
//
//            // Calculate per-policy
//            double baseAmount = policy.getMonthlyPremium() * months;
//            double gstAmount = baseAmount * taxRate.getGstRate();
//            double policyTotal = baseAmount + gstAmount;
//            totalAmount += policyTotal;
//
//            // Add per-policy tax details
//            Invoice.TaxDetails taxDetails = new Invoice.TaxDetails();
//            taxDetails.setPolicyId(policyId);  // Associate with policy
//            taxDetails.setGstRate(taxRate.getGstRate());
//            taxDetails.setTaxAmount(gstAmount);
//            taxDetails.setTotalAmount(policyTotal);
//            taxDetailsList.add(taxDetails);
//
//            validPolicyIds.add(policyId);
//        }
//
//        if (validPolicyIds.isEmpty()) {
//            throw new RuntimeException("No valid policies to generate invoice");
//        }
//
//        // Correct way to generate order ID: Create order first
//        JSONObject orderRequest = new JSONObject();
//        orderRequest.put("amount", (int) (totalAmount * 100)); // In paise
//        orderRequest.put("currency", "INR");
//        orderRequest.put("receipt", "receipt_multi_" + customerId);
//        Order razorpayOrder = razorpayClient.orders.create(orderRequest);
//        String generatedOrderId = razorpayOrder.get("id");
//        log.info("Generated Razorpay Order ID: {}", generatedOrderId);
//
//        // Generate payment link (cannot directly tie 'order_id' due to API limitation, but add to notes for reference)
//        JSONObject linkRequest = new JSONObject();
//        linkRequest.put("amount", (int) (totalAmount * 100));
//        linkRequest.put("currency", "INR");
//        linkRequest.put("accept_partial", false);
//        linkRequest.put("reference_id", customerId + "_" + System.currentTimeMillis());
//        linkRequest.put("description", "Payment for multiple policies");
//        linkRequest.put("customer", new JSONObject()
//                .put("name", customer.getName())
//                .put("email", customer.getEmail())
//                .put("contact", customer.getPhone()));
//        linkRequest.put("notify", new JSONObject().put("sms", true).put("email", true));
//        linkRequest.put("reminder_enable", true);
//        linkRequest.put("notes", new JSONObject()
//                .put("customerId", customerId)
//                .put("order_id", generatedOrderId)); // Add order_id to notes for webhook reference
//        PaymentLink paymentLink = razorpayClient.paymentLink.create(linkRequest);
//        String linkUrl = paymentLink.get("short_url");
//        log.info("Generated Payment Link: {}", linkUrl);
//
//        // Create single invoice
//        Invoice invoice = new Invoice();
//        invoice.setCustomerId(customerId);
//        invoice.setInsurerId(insurerId);
//        invoice.setPolicyIds(validPolicyIds);  // List of included policies
//        invoice.setAmount(totalAmount);
//        invoice.setStatus("unpaid");
//        invoice.setValidUpto(dueDate != null ? dueDate : calculateDueDate(currentDate, months));
//        invoice.setRazorpayOrderId(generatedOrderId);
//        invoice.setCreatedAt(new Date());
//        invoice.setPaymentLink(linkUrl);
//        invoice.setMonths(months);
//        invoice.setTaxDetailsList(taxDetailsList);  // Per-policy tax details
//
//        // Save invoice
//        Invoice savedInvoice = invoiceRepository.save(invoice);
//        log.info("Saved invoice ID: {} with razorpayOrderId: {}", savedInvoice.getId(), generatedOrderId);
//
//        // Update customer's paymentHistory for each policy
//        for (String policyId : validPolicyIds) {
//            updatePaymentHistory(customer, policyId, savedInvoice.getValidUpto());
//        }
//        customerRepository.save(customer);
//
//        return savedInvoice;
//    }
//
//    // Helper method for due date
//    private Date calculateDueDate(Date currentDate, int months) {
//        Calendar cal = Calendar.getInstance();
//        cal.setTime(currentDate);
//        cal.add(Calendar.MONTH, months);
//        return cal.getTime();
//    }
//
//    // Helper method to update paymentHistory for a policy
//    private void updatePaymentHistory(Customer customer, String policyId, Date newValidUpto) {
//        Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                .filter(entry -> entry.getPolicyId().equals(policyId))
//                .findFirst();
//
//        if (historyEntry.isPresent()) {
//            Customer.PaymentHistoryEntry entry = historyEntry.get();
//            entry.setStatus("pending invoice");
//            entry.setValidUpto(newValidUpto);
//        } else {
//            Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
//            newEntry.setPolicyId(policyId);
//            newEntry.setStatus("pending invoice");
//            newEntry.setValidUpto(newValidUpto);
//            customer.getPaymentHistory().add(newEntry);
//        }
//    }
//
//
//    public String initiatePayment(String invoiceId, String customerId) throws RazorpayException {
//        Invoice invoice = invoiceRepository.findById(invoiceId)
//                .orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//        if (!invoice.getCustomerId().equals(customerId)) {
//            throw new RuntimeException("Unauthorized");
//        }
//
//        if (!"unpaid".equals(invoice.getStatus())) {
//            throw new RuntimeException("Invoice already paid");
//        }
//
//        return invoice.getRazorpayOrderId();
//    }
//
//    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
//        try {
//            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
//            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//            invoice.setStatus("paid");
//            invoiceRepository.save(invoice);
//
//            Payment payment = new Payment();
//            payment.setInvoiceId(invoice.getId());
//            payment.setCustomerId(invoice.getCustomerId());
//            payment.setInsurerId(invoice.getInsurerId());
//            payment.setAmount(invoice.getAmount());
//            payment.setStatus(status);
//            payment.setRazorpayPaymentId(razorpayPaymentId);
//            paymentRepository.save(payment);
//
//            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
//        } catch (Exception e) {
//            log.error("Payment verification failed", e);
//            throw new RuntimeException("Payment verification failed: " + e.getMessage());
//        }
//    }
//
//    private void sendNotification(String invoiceId, String customerId, String insurerId) throws RazorpayException {
//        Notification notification = new Notification();
//        notification.setCustomerId(customerId);
//        notification.setInvoiceId(invoiceId);
//        notification.setInsurerId(insurerId);
//        notification.setType("email");
//        notification.setMessage("Payment successful for invoice " + invoiceId);
//        notificationRepository.save(notification);
//        // Add external sending logic (e.g., Twilio or SendGrid)
//    }
//
//    // NEW METHOD: Get unpaid customers
//    public List<CustomerSummary> getUnpaidCustomers() {
//        Date currentDate = new Date();
//        List<Customer> allCustomers = customerRepository.findAll();
//        return allCustomers.stream()
//                .filter(customer -> customer.getPaymentHistory().stream()
//                        .anyMatch(entry -> "unpaid".equals(entry.getStatus()) && currentDate.after(entry.getValidUpto())))
//                .map(customer -> new CustomerSummary(customer.getId(), customer.getName()))
//                .collect(Collectors.toList());
//    }
//
//    // NEW METHOD: Get unpaid policies for a customer
//    public List<PolicySummary> getUnpaidPoliciesForCustomer(String customerId) {
//        Date currentDate = new Date();
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        List<String> unpaidPolicyIds = customer.getPaymentHistory().stream()
//                .filter(entry -> "unpaid".equals(entry.getStatus()) && currentDate.after(entry.getValidUpto()))
//                .map(Customer.PaymentHistoryEntry::getPolicyId)
//                .collect(Collectors.toList());
//
//        List<Policy> unpaidPolicies = policyRepository.findAllById(unpaidPolicyIds);
//
//        return unpaidPolicies.stream()
//                .map(policy -> new PolicySummary(policy.getId(), policy.getName()))  // FIXED: Use policy.getName() for display
//                .collect(Collectors.toList());
//    }
//    
//    public void processCashPayment(String invoiceId) {
//        log.info("Processing cash payment for invoiceId: {}", invoiceId);
//
//        // Find the invoice
//        Optional<Invoice> optionalInvoice = invoiceRepository.findById(invoiceId);
//        if (optionalInvoice.isEmpty()) {
//            log.error("Invoice not found for ID: {}", invoiceId);
//            throw new RuntimeException("Invoice not found");
//        }
//        Invoice invoice = optionalInvoice.get();
//
//        // Check if already paid
//        if (!"unpaid".equals(invoice.getStatus())) {
//            log.warn("Invoice {} is not unpaid, current status: {}", invoiceId, invoice.getStatus());
//            throw new RuntimeException("Invoice is not eligible for payment");
//        }
//
//        // Update invoice status to "paidByCash"
//        invoice.setStatus("paidByCash");
//        invoiceRepository.save(invoice);
//        log.info("Updated invoice {} status to paidByCash", invoiceId);
//
//        // Create and save payment record
//        Payment payment = new Payment();
//        payment.setInvoiceId(invoice.getId());
//        payment.setCustomerId(invoice.getCustomerId());
//        payment.setInsurerId(invoice.getInsurerId());
//        payment.setAmount(invoice.getAmount());
//        payment.setStatus("paid");
//        payment.setRazorpayPaymentId(null); // No Razorpay for cash
//        payment.setRazorpaySubscriptionId(null);
//        payment.setMethod("cash");
//        payment.setIsAutoPay(false);
//        payment.setPaidAt(new Date());
//
//        // Assuming you need to add taxDetails to Payment (based on sample data)
//        // If your Payment entity doesn't have it, add a field: private TaxDetails taxDetails; (or List<TaxDetails> if multi-policy)
//        // For simplicity, copying from invoice (adjust if needed)
//        if (!invoice.getTaxDetailsList().isEmpty()) {
//            // Example: Take the first one or aggregate; here assuming single for demo
//            Invoice.TaxDetails invoiceTax = invoice.getTaxDetailsList().get(0);
//            Payment.TaxDetails taxDetails = new Payment.TaxDetails();
//            taxDetails.setTaxType("GST"); // Assuming based on sample
//            taxDetails.setTaxRate(invoiceTax.getGstRate());
//            taxDetails.setTaxAmount(invoiceTax.getTaxAmount());
//            taxDetails.setTotalAmount(invoiceTax.getTotalAmount());
//            payment.setTaxDetails(taxDetails); // Add this field to your Payment entity if not present
//        }
//
//        paymentRepository.save(payment);
//        log.info("Created payment record for invoice {}", invoiceId);
//
//        // Update customer payment history
//        Optional<Customer> optionalCustomer = customerRepository.findById(invoice.getCustomerId());
//        if (optionalCustomer.isEmpty()) {
//            log.error("Customer not found for ID: {}", invoice.getCustomerId());
//            throw new RuntimeException("Customer not found");
//        }
//        Customer customer = optionalCustomer.get();
//
//        Date paymentDate = new Date();
//        for (String policyId : invoice.getPolicyIds()) {
//            // Find or create payment history entry for the policy
//            Optional<Customer.PaymentHistoryEntry> optionalEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            Customer.PaymentHistoryEntry entry = optionalEntry.orElseGet(() -> {
//                Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
//                newEntry.setPolicyId(policyId);
//                customer.getPaymentHistory().add(newEntry);
//                log.info("Created new history entry for policy {}", policyId);
//                return newEntry;
//            });
//
//            // Update entry
//            entry.setStatus("paid");
//            entry.setLastPaidDate(paymentDate);
//            Calendar cal = Calendar.getInstance();
//            cal.setTime(paymentDate);
//            cal.add(Calendar.MONTH, invoice.getMonths());
//            entry.setValidUpto(cal.getTime());
//            log.info("Updated policy {} validUpto to {}", policyId, entry.getValidUpto());
//        }
//
//        customerRepository.save(customer);
//        log.info("Updated customer payment history for ID: {}", customer.getId());
//    }
//    
// // Update BillingService: Add or modify methods to fetch all payments (without insurerId filter)
//    public List<Payment> getAllPaymentHistory() {
//        log.info("Fetching all payment history system-wide");
//        Sort sort = Sort.by(Sort.Direction.DESC, "paidAt"); // Newest to oldest
//        return paymentRepository.findAll(sort);
//    }
//    
// // NEW: Get customer by ID
//    public Optional<Customer> getCustomerById(String customerId) {
//        return customerRepository.findById(customerId);
//    }
//
//    // NEW: Get invoice by ID
//    public Optional<Invoice> getInvoiceById(String invoiceId) {
//        return invoiceRepository.findById(invoiceId);
//    }
//
//    // NEW: Get policies by IDs (returns full Policy objects; you can map to summaries if needed)
//    public List<Policy> getPoliciesByIds(List<String> policyIds) {
//        return policyRepository.findAllById(policyIds);
//    }
//    public List<Invoice> getAllInvoiceHistory() {
//        log.info("Fetching all invoice history system-wide");
//        Sort sort = Sort.by(Sort.Direction.DESC, "createdAt"); // Newest to oldest
//        return invoiceRepository.findAll(sort);
//    }
//    
// // Add to BillingService.java
//
// // NEW: Search customers by name (case-insensitive partial match)
// public List<CustomerSummary> searchCustomersByName(String name) {
//     log.info("Searching customers with name containing: {}", name);
//     List<Customer> matchingCustomers = customerRepository.findByNameContainingIgnoreCase(name);
//     return matchingCustomers.stream()
//             .map(customer -> new CustomerSummary(customer.getId(), customer.getName()))
//             .collect(Collectors.toList());
// }
//
////NEW: Get unpaid and failed invoices for a customer
//public List<Invoice> getUnpaidFailedInvoicesForCustomer(String customerId) {
//  log.info("Fetching unpaid/failed invoices for customer: {}", customerId);
//  return invoiceRepository.findByCustomerIdAndStatusIn(customerId, List.of("unpaid", "failed"));  // Assumes status can be "unpaid" or "failed"; adjust as needed
//}
//
////NEW: Process cash payment for multiple invoices
//public void processCashPaymentMultiple(List<String> invoiceIds) {
//  log.info("Processing cash payment for multiple invoices: {}", invoiceIds);
//  for (String invoiceId : invoiceIds) {
//      processCashPayment(invoiceId);  // Reuse your existing single-invoice method for each
//  }
//}
//
//
//}
//











//package com.example.service;
//
//import com.example.dto.CustomerSummary;
//import com.example.dto.PolicySummary;
//import com.example.model.Customer;
//import com.example.model.Invoice;
//import com.example.model.Notification;
//import com.example.model.Payment;
//import com.example.model.Policy;
//import com.example.model.TaxRate;
//import com.example.repository.CustomerRepository;
//import com.example.repository.InvoiceRepository;
//import com.example.repository.NotificationRepository;
//import com.example.repository.PaymentRepository;
//import com.example.repository.PolicyRepository;
//import com.example.repository.TaxRateRepository;
//import com.razorpay.Order;
//import com.razorpay.RazorpayClient;
//import com.razorpay.RazorpayException;
//import com.razorpay.PaymentLink;
//import org.json.JSONObject;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.stereotype.Service;
//
//import java.util.ArrayList;
//import java.util.Date;
//import java.util.List;
//import java.util.Optional;
//import java.util.Calendar;
//import java.util.stream.Collectors;
//
//@Service
//public class BillingService {
//
//    private static final Logger log = LoggerFactory.getLogger(BillingService.class);
//
//    @Autowired
//    private InvoiceRepository invoiceRepository;
//
//    @Autowired
//    private PolicyRepository policyRepository;
//
//    @Autowired
//    private PaymentRepository paymentRepository;
//
//    @Autowired
//    private NotificationRepository notificationRepository;
//
//    @Autowired
//    private CustomerRepository customerRepository;
//
//    @Autowired
//    private TaxRateRepository taxRateRepository;
//
//    private final RazorpayClient razorpayClient;
//
//    public BillingService(
//            @Value("${razorpay.key-id}") String keyId,
//            @Value("${razorpay.key-secret}") String keySecret) throws RazorpayException {
//        this.razorpayClient = new RazorpayClient(keyId, keySecret);
//    }
//
//    public Invoice createInvoice(String customerId, List<String> policyIds, String insurerId, Date dueDate, int months) throws RazorpayException {
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        Date currentDate = new Date();
//        List<String> validPolicyIds = new ArrayList<>();
//        List<Invoice.TaxDetails> taxDetailsList = new ArrayList<>();
//        double totalAmount = 0.0;
//
//        // Loop to validate policies and calculate dynamic amounts/taxes
//        for (String policyId : policyIds) {
//            Policy policy = policyRepository.findById(policyId)
//                    .orElseThrow(() -> new RuntimeException("Policy not found"));
//
//            // Constraint check (skip if not unpaid and expired)
//            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            if (historyEntry.isPresent()) {
//                Customer.PaymentHistoryEntry entry = historyEntry.get();
//                if (!currentDate.after(entry.getValidUpto()) || !"unpaid".equals(entry.getStatus())) {
//                    log.warn("Skipping policy {}: Valid until {} or status not unpaid", policyId, entry.getValidUpto());
//                    continue;
//                }
//            } else {
//                log.info("No payment history for policy {}; including in invoice", policyId);
//            }
//
//            // Fetch tax rate dynamically from collection
//            String taxRateId = policy.getPolicyType();
//            TaxRate taxRate = taxRateRepository.findById(taxRateId)
//                    .orElseThrow(() -> new RuntimeException("TaxRate not found for ID: " + taxRateId));
//
//            // Calculate per-policy
//            double baseAmount = policy.getMonthlyPremium() * months;
//            double gstAmount = baseAmount * taxRate.getGstRate();
//            double policyTotal = baseAmount + gstAmount;
//            totalAmount += policyTotal;
//
//            // Add per-policy tax details
//            Invoice.TaxDetails taxDetails = new Invoice.TaxDetails();
//            taxDetails.setPolicyId(policyId);  // Associate with policy
//            taxDetails.setGstRate(taxRate.getGstRate());
//            taxDetails.setTaxAmount(gstAmount);
//            taxDetails.setTotalAmount(policyTotal);
//            taxDetailsList.add(taxDetails);
//
//            validPolicyIds.add(policyId);
//        }
//
//        if (validPolicyIds.isEmpty()) {
//            throw new RuntimeException("No valid policies to generate invoice");
//        }
//
//        // Create single Razorpay order for total
//        JSONObject orderRequest = new JSONObject();
//        orderRequest.put("amount", (int) (totalAmount * 100)); // In paise
//        orderRequest.put("currency", "INR");
//        orderRequest.put("receipt", "receipt_multi_" + customerId);
//        Order razorpayOrder = razorpayClient.orders.create(orderRequest);
//
//        // Generate single payment link
//        JSONObject linkRequest = new JSONObject();
//        linkRequest.put("amount", (int) (totalAmount * 100));
//        linkRequest.put("currency", "INR");
//        linkRequest.put("accept_partial", false);
//        linkRequest.put("reference_id", customerId + "_" + System.currentTimeMillis());
//        linkRequest.put("description", "Payment for multiple policies");
//        linkRequest.put("customer", new JSONObject()
//                .put("name", customer.getName())
//                .put("email", customer.getEmail())
//                .put("contact", customer.getPhone()));
//        linkRequest.put("notify", new JSONObject().put("sms", true).put("email", true));
//        linkRequest.put("reminder_enable", true);
//        linkRequest.put("notes", new JSONObject().put("customerId", customerId));
//        PaymentLink paymentLink = razorpayClient.paymentLink.create(linkRequest);
//        String linkUrl = paymentLink.get("short_url");
//
//        // Create single invoice
//        Invoice invoice = new Invoice();
//        invoice.setCustomerId(customerId);
//        invoice.setInsurerId(insurerId);
//        invoice.setPolicyIds(validPolicyIds);  // List of included policies
//        invoice.setAmount(totalAmount);
//        invoice.setStatus("unpaid");
//        invoice.setDueDate(dueDate != null ? dueDate : calculateDueDate(currentDate, months));
//        invoice.setRazorpayOrderId(razorpayOrder.get("id"));
//        invoice.setCreatedAt(new Date());
//        invoice.setPaymentLink(linkUrl);
//        invoice.setMonths(months);
//        invoice.setTaxDetailsList(taxDetailsList);  // Per-policy tax details
//
//        // Save invoice
//        Invoice savedInvoice = invoiceRepository.save(invoice);
//
//        // Update customer's paymentHistory for each policy
//        for (String policyId : validPolicyIds) {
//            updatePaymentHistory(customer, policyId, savedInvoice.getDueDate());
//        }
//        customerRepository.save(customer);
//
//        return savedInvoice;
//    }
//
//    // Helper method for due date
//    private Date calculateDueDate(Date currentDate, int months) {
//        Calendar cal = Calendar.getInstance();
//        cal.setTime(currentDate);
//        cal.add(Calendar.MONTH, months);
//        return cal.getTime();
//    }
//
//    // Helper method to update paymentHistory for a policy
//    private void updatePaymentHistory(Customer customer, String policyId, Date newValidUpto) {
//        Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                .filter(entry -> entry.getPolicyId().equals(policyId))
//                .findFirst();
//
//        if (historyEntry.isPresent()) {
//            Customer.PaymentHistoryEntry entry = historyEntry.get();
//            entry.setStatus("pending invoice");
//            entry.setValidUpto(newValidUpto);
//        } else {
//            Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
//            newEntry.setPolicyId(policyId);
//            newEntry.setStatus("pending invoice");
//            newEntry.setValidUpto(newValidUpto);
//            customer.getPaymentHistory().add(newEntry);
//        }
//    }
//
//
//    public String initiatePayment(String invoiceId, String customerId) throws RazorpayException {
//        Invoice invoice = invoiceRepository.findById(invoiceId)
//                .orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//        if (!invoice.getCustomerId().equals(customerId)) {
//            throw new RuntimeException("Unauthorized");
//        }
//
//        if (!"unpaid".equals(invoice.getStatus())) {
//            throw new RuntimeException("Invoice already paid");
//        }
//
//        return invoice.getRazorpayOrderId();
//    }
//
//    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
//        try {
//            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
//            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//            invoice.setStatus("paid");
//            invoiceRepository.save(invoice);
//
//            Payment payment = new Payment();
//            payment.setInvoiceId(invoice.getId());
//            payment.setCustomerId(invoice.getCustomerId());
//            payment.setInsurerId(invoice.getInsurerId());
//            payment.setAmount(invoice.getAmount());
//            payment.setStatus(status);
//            payment.setRazorpayPaymentId(razorpayPaymentId);
//            paymentRepository.save(payment);
//
//            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
//        } catch (Exception e) {
//            log.error("Payment verification failed", e);
//            throw new RuntimeException("Payment verification failed: " + e.getMessage());
//        }
//    }
//
//    private void sendNotification(String invoiceId, String customerId, String insurerId) throws RazorpayException {
//        Notification notification = new Notification();
//        notification.setCustomerId(customerId);
//        notification.setInvoiceId(invoiceId);
//        notification.setInsurerId(insurerId);
//        notification.setType("email");
//        notification.setMessage("Payment successful for invoice " + invoiceId);
//        notificationRepository.save(notification);
//        // Add external sending logic (e.g., Twilio or SendGrid)
//    }
//
//    // NEW METHOD: Get unpaid customers
//    public List<CustomerSummary> getUnpaidCustomers() {
//        Date currentDate = new Date();
//        List<Customer> allCustomers = customerRepository.findAll();
//        return allCustomers.stream()
//                .filter(customer -> customer.getPaymentHistory().stream()
//                        .anyMatch(entry -> "unpaid".equals(entry.getStatus()) && currentDate.after(entry.getValidUpto())))
//                .map(customer -> new CustomerSummary(customer.getId(), customer.getName()))
//                .collect(Collectors.toList());
//    }
//
//    // NEW METHOD: Get unpaid policies for a customer
//    public List<PolicySummary> getUnpaidPoliciesForCustomer(String customerId) {
//        Date currentDate = new Date();
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        List<String> unpaidPolicyIds = customer.getPaymentHistory().stream()
//                .filter(entry -> "unpaid".equals(entry.getStatus()) && currentDate.after(entry.getValidUpto()))
//                .map(Customer.PaymentHistoryEntry::getPolicyId)
//                .collect(Collectors.toList());
//
//        List<Policy> unpaidPolicies = policyRepository.findAllById(unpaidPolicyIds);
//
//        return unpaidPolicies.stream()
//                .map(policy -> new PolicySummary(policy.getId(), policy.getName()))  // FIXED: Use policy.getName() for display
//                .collect(Collectors.toList());
//    }
//}



//package com.example.service;
//
//import com.example.dto.CustomerSummary;
//import com.example.dto.PolicySummary;
//import com.example.model.Customer;
//import com.example.model.Invoice;
//import com.example.model.Notification;
//import com.example.model.Payment;
//import com.example.model.Policy;
//import com.example.model.TaxRate;
//import com.example.repository.CustomerRepository;
//import com.example.repository.InvoiceRepository;
//import com.example.repository.NotificationRepository;
//import com.example.repository.PaymentRepository;
//import com.example.repository.PolicyRepository;
//import com.example.repository.TaxRateRepository;
//import com.razorpay.Order;
//import com.razorpay.RazorpayClient;
//import com.razorpay.RazorpayException;
//import org.json.JSONObject;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.stereotype.Service;
//import com.razorpay.PaymentLink;
//
//import java.util.ArrayList;
//import java.util.Date;
//import java.util.List;
//import java.util.Optional;
//import java.util.Calendar;
//import java.util.stream.Collectors;
//
//@Service
//public class BillingService {
//
//    private static final Logger log = LoggerFactory.getLogger(BillingService.class);
//
//    @Autowired
//    private InvoiceRepository invoiceRepository;
//
//    @Autowired
//    private PolicyRepository policyRepository;
//
//    @Autowired
//    private PaymentRepository paymentRepository;
//
//    @Autowired
//    private NotificationRepository notificationRepository;
//
//    @Autowired
//    private CustomerRepository customerRepository;
//
//    @Autowired
//    private TaxRateRepository taxRateRepository;
//
//    private final RazorpayClient razorpayClient;
//
//    public BillingService(
//            @Value("${razorpay.key-id}") String keyId,
//            @Value("${razorpay.key-secret}") String keySecret) throws RazorpayException {
//        this.razorpayClient = new RazorpayClient(keyId, keySecret);
//    }
//
//    public List<Invoice> createInvoice(String customerId, List<String> policyIds, String insurerId, Date dueDate, int months) throws RazorpayException {
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        Date currentDate = new Date();
//        List<Invoice> generatedInvoices = new ArrayList<>();
//
//        for (String policyId : policyIds) {
//            // Fetch policy and monthlyPremium
//            Policy policy = policyRepository.findById(policyId)
//                    .orElseThrow(() -> new RuntimeException("Policy not found"));
//
//            // Constraint Check: current date > validUpto and status = "unpaid" for this policy
//            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            if (historyEntry.isPresent()) {
//                Customer.PaymentHistoryEntry entry = historyEntry.get();
//                if (!currentDate.after(entry.getValidUpto()) || !"unpaid".equals(entry.getStatus())) {
//                    log.warn("Skipping policy {}: Valid until {} or status not unpaid", policyId, entry.getValidUpto());
//                    continue;
//                }
//            } else {
//                log.info("No payment history for policy {}; generating invoice", policyId);
//            }
//
//            // Fetch TaxRate by policy's policyType OID
//            String taxRateId = policy.getPolicyType();
//            TaxRate taxRate = taxRateRepository.findById(taxRateId)
//                    .orElseThrow(() -> new RuntimeException("TaxRate not found for ID: " + taxRateId));
//
//            // Calculate per-policy amount + GST
//            double baseAmount = policy.getMonthlyPremium() * months;
//            double gstAmount = baseAmount * taxRate.getGstRate();
//            double totalAmount = baseAmount + gstAmount;
//
//            // Create Razorpay order for this policy
//            JSONObject orderRequest = new JSONObject();
//            orderRequest.put("amount", (int) (totalAmount * 100)); // In paise
//            orderRequest.put("currency", "INR");
//            orderRequest.put("receipt", "receipt_" + policyId);
//            Order razorpayOrder = razorpayClient.orders.create(orderRequest);
//
//            // NEW: Generate payment link for this order
//            JSONObject linkRequest = new JSONObject();
//            linkRequest.put("amount", (int) (totalAmount * 100));
//            linkRequest.put("currency", "INR");
//            linkRequest.put("accept_partial", false);
//            linkRequest.put("reference_id", policyId);
//            linkRequest.put("description", "Payment for policy " + policyId);
//            linkRequest.put("customer", new JSONObject()
//                    .put("name", customer.getName())
//                    .put("email", customer.getEmail())
//                    .put("contact", customer.getPhone()));
//            linkRequest.put("notify", new JSONObject().put("sms", true).put("email", true));
//            linkRequest.put("reminder_enable", true);
//            linkRequest.put("notes", new JSONObject().put("customerId", customerId));
//            PaymentLink paymentLink = razorpayClient.paymentLink.create(linkRequest);
//
//            String linkUrl = paymentLink.get("short_url");  // Short, shareable URL
//
//            // Create invoice for this policy
//            Invoice invoice = new Invoice();
//            invoice.setCustomerId(customerId);
//            invoice.setPolicyId(policyId);  // One policy per invoice
//            invoice.setInsurerId(insurerId);  // Same insurer for all
//            invoice.setAmount(totalAmount);
//            invoice.setStatus("unpaid");
//
//            // Set dueDate per invoice: If null, calculate as current + (months * 30 days)
//            Date invoiceDueDate = dueDate;
//            if (invoiceDueDate == null) {
//                Calendar cal = Calendar.getInstance();
//                cal.setTime(currentDate);
//                cal.add(Calendar.MONTH, months);
//                invoiceDueDate = cal.getTime();
//            }
//            invoice.setDueDate(invoiceDueDate);
//
//            invoice.setRazorpayOrderId(razorpayOrder.get("id"));
//            invoice.setCreatedAt(new Date());
//
//            // NEW: Set the generated payment link
//            invoice.setPaymentLink(linkUrl);
//
//            // Set taxDetails
//            Invoice.TaxDetails taxDetails = new Invoice.TaxDetails();
//            taxDetails.setGstRate(taxRate.getGstRate());
//            taxDetails.setTaxAmount(gstAmount);
//            taxDetails.setTotalAmount(totalAmount);
//            invoice.setTaxDetails(taxDetails);
//
//            // Save invoice to collection (with payment link)
//            generatedInvoices.add(invoiceRepository.save(invoice));
//        }
//
//        // After all invoices generated, update customer's paymentHistory for each generated policy
//        for (Invoice invoice : generatedInvoices) {
//            String policyId = invoice.getPolicyId();
//            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            Date newValidUpto = invoice.getDueDate();  // Sync validUpto to invoice dueDate
//
//            if (historyEntry.isPresent()) {
//                Customer.PaymentHistoryEntry entry = historyEntry.get();
//                entry.setStatus("pending invoice");
//                entry.setValidUpto(newValidUpto);  // Update validUpto
//            } else {
//                // Add new entry if no history
//                Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
//                newEntry.setPolicyId(policyId);
//                newEntry.setStatus("pending invoice");
//                newEntry.setValidUpto(newValidUpto);
//                customer.getPaymentHistory().add(newEntry);
//            }
//        }
//        customerRepository.save(customer);  // Single save after all updates
//
//        if (generatedInvoices.isEmpty()) {
//            throw new RuntimeException("No invoices generated: All policies skipped due to valid coverage or status not unpaid");
//        }
//
//        return generatedInvoices;
//    }
//
//    public String initiatePayment(String invoiceId, String customerId) throws RazorpayException {
//        Invoice invoice = invoiceRepository.findById(invoiceId)
//                .orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//        if (!invoice.getCustomerId().equals(customerId)) {
//            throw new RuntimeException("Unauthorized");
//        }
//
//        if (!"unpaid".equals(invoice.getStatus())) {
//            throw new RuntimeException("Invoice already paid");
//        }
//
//        return invoice.getRazorpayOrderId();
//    }
//
//    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
//        try {
//            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
//            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//            invoice.setStatus("paid");
//            invoiceRepository.save(invoice);
//
//            Payment payment = new Payment();
//            payment.setInvoiceId(invoice.getId());
//            payment.setCustomerId(invoice.getCustomerId());
//            payment.setInsurerId(invoice.getInsurerId());
//            payment.setAmount(invoice.getAmount());
//            payment.setStatus(status);
//            payment.setRazorpayPaymentId(razorpayPaymentId);
//            paymentRepository.save(payment);
//
//            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
//        } catch (Exception e) {
//            log.error("Payment verification failed", e);
//            throw new RuntimeException("Payment verification failed: " + e.getMessage());
//        }
//    }
//
//    private void sendNotification(String invoiceId, String customerId, String insurerId) throws RazorpayException {
//        Notification notification = new Notification();
//        notification.setCustomerId(customerId);
//        notification.setInvoiceId(invoiceId);
//        notification.setInsurerId(insurerId);
//        notification.setType("email");
//        notification.setMessage("Payment successful for invoice " + invoiceId);
//        notificationRepository.save(notification);
//        // Add external sending logic (e.g., Twilio or SendGrid)
//    }
//
//    // NEW METHOD: Get unpaid customers
//    public List<CustomerSummary> getUnpaidCustomers() {
//        Date currentDate = new Date();
//        List<Customer> allCustomers = customerRepository.findAll();
//        return allCustomers.stream()
//                .filter(customer -> customer.getPaymentHistory().stream()
//                        .anyMatch(entry -> "unpaid".equals(entry.getStatus()) && currentDate.after(entry.getValidUpto())))
//                .map(customer -> new CustomerSummary(customer.getId(), customer.getName()))
//                .collect(Collectors.toList());
//    }
//
//    // NEW METHOD: Get unpaid policies for a customer
//    public List<PolicySummary> getUnpaidPoliciesForCustomer(String customerId) {
//        Date currentDate = new Date();
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        List<String> unpaidPolicyIds = customer.getPaymentHistory().stream()
//                .filter(entry -> "unpaid".equals(entry.getStatus()) && currentDate.after(entry.getValidUpto()))
//                .map(Customer.PaymentHistoryEntry::getPolicyId)
//                .collect(Collectors.toList());
//
//        List<Policy> unpaidPolicies = policyRepository.findAllById(unpaidPolicyIds);
//
//        return unpaidPolicies.stream()
//                .map(policy -> new PolicySummary(policy.getId(), policy.getName()))  // FIXED: Use policy.getName() for display
//                .collect(Collectors.toList());
//    }
//}
//






//package com.example.service;
//
//import com.example.model.Customer;
//import com.example.model.Invoice;
//import com.example.model.Notification;
//import com.example.model.Payment;
//import com.example.model.Policy;
//import com.example.model.TaxRate;
//import com.example.repository.CustomerRepository;
//import com.example.repository.InvoiceRepository;
//import com.example.repository.NotificationRepository;
//import com.example.repository.PaymentRepository;
//import com.example.repository.PolicyRepository;
//import com.example.repository.TaxRateRepository;
//import com.razorpay.Order;
//import com.razorpay.RazorpayClient;
//import com.razorpay.RazorpayException;
//import org.json.JSONObject;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.stereotype.Service;
//
//import java.util.ArrayList;
//import java.util.Date;
//import java.util.List;
//import java.util.Optional;
//import java.util.Calendar;
//
//@Service
//public class BillingService {
//
//    private static final Logger log = LoggerFactory.getLogger(BillingService.class);
//
//    @Autowired
//    private InvoiceRepository invoiceRepository;
//
//    @Autowired
//    private PolicyRepository policyRepository;
//
//    @Autowired
//    private PaymentRepository paymentRepository;
//
//    @Autowired
//    private NotificationRepository notificationRepository;
//
//    @Autowired
//    private CustomerRepository customerRepository;
//
//    @Autowired
//    private TaxRateRepository taxRateRepository;
//
//    private final RazorpayClient razorpayClient;
//
//    public BillingService(
//            @Value("${razorpay.key-id}") String keyId,
//            @Value("${razorpay.key-secret}") String keySecret) throws RazorpayException {
//        this.razorpayClient = new RazorpayClient(keyId, keySecret);
//    }
//
//    // Generate one invoice per policy with per-policy calculations, constraints, and customer updates
//    public List<Invoice> createInvoice(String customerId, List<String> policyIds, String insurerId, Date dueDate, int months) throws RazorpayException {
//        Customer customer = customerRepository.findById(customerId)
//                .orElseThrow(() -> new RuntimeException("Customer not found"));
//
//        Date currentDate = new Date();
//        List<Invoice> generatedInvoices = new ArrayList<>();
//
//        for (String policyId : policyIds) {
//            // Fetch policy and monthlyPremium
//            Policy policy = policyRepository.findById(policyId)
//                    .orElseThrow(() -> new RuntimeException("Policy not found"));
//
//            // Constraint Check: current date > validUpto and status = "unpaid" for this policy
//            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            if (historyEntry.isPresent()) {
//                Customer.PaymentHistoryEntry entry = historyEntry.get();
//                if (!currentDate.after(entry.getValidUpto()) || !"unpaid".equals(entry.getStatus())) {
//                    log.warn("Skipping policy {}: Valid until {} or status not unpaid", policyId, entry.getValidUpto());
//                    continue;
//                }
//            } else {
//                log.info("No payment history for policy {}; generating invoice", policyId);
//            }
//
//            // Fetch TaxRate by policy's policyType OID
//            String taxRateId = policy.getPolicyType();
//            TaxRate taxRate = taxRateRepository.findById(taxRateId)
//                    .orElseThrow(() -> new RuntimeException("TaxRate not found for ID: " + taxRateId));
//
//            // Calculate per-policy amount + GST
//            double baseAmount = policy.getMonthlyPremium() * months;
//            double gstAmount = baseAmount * taxRate.getGstRate();
//            double totalAmount = baseAmount + gstAmount;
//
//            // Create Razorpay order for this policy
//            JSONObject orderRequest = new JSONObject();
//            orderRequest.put("amount", (int) (totalAmount * 100)); // In paise
//            orderRequest.put("currency", "INR");
//            orderRequest.put("receipt", "receipt_" + policyId);
//            Order razorpayOrder = razorpayClient.orders.create(orderRequest);
//
//            // Create invoice for this policy
//            Invoice invoice = new Invoice();
//            invoice.setCustomerId(customerId);
//            invoice.setPolicyId(policyId);  // One policy per invoice
//            invoice.setInsurerId(insurerId);  // Same insurer for all
//            invoice.setAmount(totalAmount);
//            invoice.setStatus("unpaid");
//
//            // Set dueDate per invoice: If null, calculate as current + (months * 30 days)
//            Date invoiceDueDate = dueDate;
//            if (invoiceDueDate == null) {
//                Calendar cal = Calendar.getInstance();
//                cal.setTime(currentDate);
//                cal.add(Calendar.MONTH, months);
//                invoiceDueDate = cal.getTime();
//            }
//            invoice.setDueDate(invoiceDueDate);
//
//            invoice.setRazorpayOrderId(razorpayOrder.get("id"));
//            invoice.setCreatedAt(new Date());
//
//            // Set taxDetails
//            Invoice.TaxDetails taxDetails = new Invoice.TaxDetails();
//            taxDetails.setGstRate(taxRate.getGstRate());
//            taxDetails.setTaxAmount(gstAmount);
//            taxDetails.setTotalAmount(totalAmount);
//            invoice.setTaxDetails(taxDetails);
//
//            // Save invoice to collection
//            generatedInvoices.add(invoiceRepository.save(invoice));
//        }
//
//        // After all invoices generated, update customer's paymentHistory for each generated policy
//        for (Invoice invoice : generatedInvoices) {
//            String policyId = invoice.getPolicyId();
//            Optional<Customer.PaymentHistoryEntry> historyEntry = customer.getPaymentHistory().stream()
//                    .filter(entry -> entry.getPolicyId().equals(policyId))
//                    .findFirst();
//
//            Date newValidUpto = invoice.getDueDate();  // Sync validUpto to invoice dueDate
//
//            if (historyEntry.isPresent()) {
//                Customer.PaymentHistoryEntry entry = historyEntry.get();
//                entry.setStatus("pending invoice");
//                entry.setValidUpto(newValidUpto);  // Update validUpto
//            } else {
//                // Add new entry if no history
//                Customer.PaymentHistoryEntry newEntry = new Customer.PaymentHistoryEntry();
//                newEntry.setPolicyId(policyId);
//                newEntry.setStatus("pending invoice");
//                newEntry.setValidUpto(newValidUpto);
//                customer.getPaymentHistory().add(newEntry);
//            }
//        }
//        customerRepository.save(customer);  // Single save after all updates
//
//        if (generatedInvoices.isEmpty()) {
//            throw new RuntimeException("No invoices generated: All policies skipped due to valid coverage or status not unpaid");
//        }
//
//        return generatedInvoices;
//    }
//
//    public String initiatePayment(String invoiceId, String customerId) throws RazorpayException {
//        Invoice invoice = invoiceRepository.findById(invoiceId)
//                .orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//        if (!invoice.getCustomerId().equals(customerId)) {
//            throw new RuntimeException("Unauthorized");
//        }
//
//        if (!"unpaid".equals(invoice.getStatus())) {
//            throw new RuntimeException("Invoice already paid");
//        }
//
//        return invoice.getRazorpayOrderId();
//    }
//
//    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
//        try {
//            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
//            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//            invoice.setStatus("paid");
//            invoiceRepository.save(invoice);
//
//            Payment payment = new Payment();
//            payment.setInvoiceId(invoice.getId());
//            payment.setCustomerId(invoice.getCustomerId());
//            payment.setInsurerId(invoice.getInsurerId());
//            payment.setAmount(invoice.getAmount());
//            payment.setStatus(status);
//            payment.setRazorpayPaymentId(razorpayPaymentId);
//            paymentRepository.save(payment);
//
//            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
//        } catch (Exception e) {
//            log.error("Payment verification failed", e);
//            throw new RuntimeException("Payment verification failed: " + e.getMessage());
//        }
//    }
//
//    private void sendNotification(String invoiceId, String customerId, String insurerId) throws RazorpayException {
//        Notification notification = new Notification();
//        notification.setCustomerId(customerId);
//        notification.setInvoiceId(invoiceId);
//        notification.setInsurerId(insurerId);
//        notification.setType("email");
//        notification.setMessage("Payment successful for invoice " + invoiceId);
//        notificationRepository.save(notification);
//        // Add external sending logic (e.g., Twilio or SendGrid)
//    }
//}

//package com.example.service;
//
//import com.example.model.Invoice;
//import com.example.model.Notification;
//import com.example.model.Payment;
//import com.example.model.Policy;
//import com.example.repository.InvoiceRepository;
//import com.example.repository.NotificationRepository;
//import com.example.repository.PaymentRepository;
//import com.example.repository.PolicyRepository;
//import com.razorpay.Order;
//import com.razorpay.RazorpayClient;
//import com.razorpay.RazorpayException;
//import org.json.JSONObject;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.stereotype.Service;
//
//import java.util.Date;
//import java.util.Optional;
//
//@Service
//public class BillingService {
//
//    private final InvoiceRepository invoiceRepository;
//    private final PolicyRepository policyRepository;
//    private final PaymentRepository paymentRepository;
//    private final NotificationRepository notificationRepository;
//    private final RazorpayClient razorpayClient;
//
//    public BillingService(
//            InvoiceRepository invoiceRepository,
//            PolicyRepository policyRepository,
//            PaymentRepository paymentRepository,
//            NotificationRepository notificationRepository,
//            @Value("${razorpay.key-id}") String keyId,
//            @Value("${razorpay.key-secret}") String keySecret) throws RazorpayException {
//        this.invoiceRepository = invoiceRepository;
//        this.policyRepository = policyRepository;
//        this.paymentRepository = paymentRepository;
//        this.notificationRepository = notificationRepository;
//        this.razorpayClient = new RazorpayClient(keyId, keySecret);
//    }
//
//    public Invoice createInvoice(String customerId, String policyId, String insurerId, Date dueDate) throws RazorpayException {
//        // Fetch policy to get premium amount
//        Policy policy = policyRepository.findById(policyId)
//                .orElseThrow(() -> new RuntimeException("Policy not found"));
//
//        // Check authorization (simplified; add JWT logic later)
//        if (!policy.getInsurerId().equals(insurerId)) {
//            throw new RuntimeException("Unauthorized");
//        }
//
//        // Create Razorpay order
//        JSONObject orderRequest = new JSONObject();
//        orderRequest.put("amount", (int) (policy.getMonthlyPremium() * 100)); // Amount in paise
//        orderRequest.put("currency", "INR");
//        orderRequest.put("receipt", "receipt_" + policyId);
//        Order razorpayOrder = razorpayClient.orders.create(orderRequest);
//
//        // Create and save invoice
//        Invoice invoice = new Invoice();
//        invoice.setCustomerId(customerId);
//        invoice.setPolicyId(policyId);
//        invoice.setInsurerId(insurerId);
//        invoice.setAmount(policy.getMonthlyPremium());
//        invoice.setStatus("unpaid");
//        invoice.setDueDate(dueDate);
//        invoice.setRazorpayOrderId(razorpayOrder.get("id"));
//        invoice.setCreatedAt(new Date());
//
//        return invoiceRepository.save(invoice);
//    }
//
//    // New method to initiate payment (called from controller)
//    public String initiatePayment(String invoiceId, String customerId) throws RazorpayException {
//        Invoice invoice = invoiceRepository.findById(invoiceId)
//                .orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//        if (!invoice.getCustomerId().equals(customerId)) {
//            throw new RuntimeException("Unauthorized");
//        }
//
//        if (!"unpaid".equals(invoice.getStatus())) {
//            throw new RuntimeException("Invoice already paid");
//        }
//
//        // Return the Razorpay order ID for frontend checkout
//        return invoice.getRazorpayOrderId();  // Already generated during invoice creation
//    }
//
//    // Webhook method to verify payment and update DB
//    public void verifyPayment(String razorpayPaymentId, String razorpayOrderId, String status) {
//        try {
//            // Verify with Razorpay API (use SDK to fetch payment details)
//            // For simplicity, assume success if status == "success" (adjust based on actual webhook payload)
//
//            Optional<Invoice> optionalInvoice = invoiceRepository.findByRazorpayOrderId(razorpayOrderId);
//            Invoice invoice = optionalInvoice.orElseThrow(() -> new RuntimeException("Invoice not found"));
//
//            // Update invoice status
//            invoice.setStatus("paid");
//            invoiceRepository.save(invoice);
//
//            // Create payment record
//            Payment payment = new Payment();
//            payment.setInvoiceId(invoice.getId());
//            payment.setCustomerId(invoice.getCustomerId());
//            payment.setInsurerId(invoice.getInsurerId());
//            payment.setAmount(invoice.getAmount());
//            payment.setStatus(status); // success or failed
//            payment.setRazorpayPaymentId(razorpayPaymentId);
//            paymentRepository.save(payment);
//
//            // Send notification via Razorpay (email/SMS)
//            sendNotification(invoice.getId(), invoice.getCustomerId(), invoice.getInsurerId());
//        } catch (Exception e) {
//            // Log error (add logging)
//            throw new RuntimeException("Payment verification failed: " + e.getMessage());
//        }
//    }
//
//    // Method to send notification using Razorpay API
//    private void sendNotification(String invoiceId, String customerId, String insurerId) throws RazorpayException {
//        // Fetch customer details if needed (e.g., email/phone from customers collection)
//		// Note: Razorpay's notifyBy requires a Razorpay entity ID (e.g., their invoice ID). If using custom invoices,
//		// replace with Razorpay's payment email/SMS API or a third-party service like Twilio/SendGrid.
//		// Example assuming you have a Razorpay invoice ID (adapt as needed):
//		JSONObject notifyRequest = new JSONObject();
//		notifyRequest.put("medium", "email");  // or "sms"
//		// razorpayClient.invoices.notifyBy(razorpayInvoiceId, notifyRequest);  // Use actual Razorpay invoice ID
//
//		// Save notification record (even if external send fails)
//		Notification notification = new Notification();
//		notification.setCustomerId(customerId);
//		notification.setInvoiceId(invoiceId);
//		notification.setInsurerId(insurerId);
//		notification.setType("email");
//		notification.setMessage("Payment successful for invoice " + invoiceId);
//		notificationRepository.save(notification);
//    }
//}
